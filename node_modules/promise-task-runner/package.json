{
  "name": "promise-task-runner",
  "main": "index.js",
  "version": "0.0.1",
  "description": "- This readme covers a few basics.  For anything more, please see the wiki.  - To avoid confusion, the abbreviation 'ptr' is for promise-task-runner.",
  "bin": {
    "ptr": "./bin/cli.js"
  },
  "scripts": {
    "test": "mocha -u tdd --no-colors --reporter spec --require mocha-clean tests/*"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/olsonpm/promise-task-runner.git"
  },
  "author": {
    "name": "Phil Olson",
    "email": "philip.olson@protonmail.ch",
    "url": "https://github.com/olsonpm"
  },
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/olsonpm/promise-task-runner/issues"
  },
  "homepage": "https://github.com/olsonpm/promise-task-runner",
  "dependencies": {
    "bluebird": "^2.9.3",
    "chai": "^1.10.0",
    "commander": "^2.6.0",
    "component-xor": "0.0.3",
    "fs-bluebird": "^0.1.1",
    "lazy.js": "^0.4.0",
    "mocha": "^2.1.0",
    "mocha-clean": "^0.4.0",
    "toposort-class": "^0.3.1"
  },
  "readme": "# promise-task-runner\n\n - This readme covers a few basics.  For anything more, please see the wiki.\n - To avoid confusion, the abbreviation 'ptr' is for promise-task-runner.\n\n## First of all, why does promise-task-runner exist?\nBecause I liked the concept of a streaming build-system as made popular by Gulp, but I didn't like its task management library.  Specifically I wanted to pass command line arguments to my tasks as well as pass task results down the dependency chain.  I looked around on npm and there were no existing promise-based task libraries, thus I built my own.\n\n## Why would I want to use this library?\nIf you're like me and want to pass command line arguments to your tasks, as well as pass task results down the dependency chain.  You might also like the promise-based interface to running tasks.\n\n## What does a task look like?\nYou declare a task using the PromiseTask object\n```\n// tasks/scripts.js\nvar ptr = require('promise-task-runner');\nvar PromiseTask = ptr.PromiseTask\nvar scripts = new PromiseTask()\n  .id('scripts')\n  .task(function() {\n    // task logic\n  });\n```\nThen add it to a PromiseTaskContainer and export the container\n```\n// tasks/scripts.js\n...\nvar PromiseTaskContainer = ptr.PromiseTaskContainer;\nvar ptc = new PromiseTaskContainer();\nptc.addTask(scripts);\nmodule.exports = ptc;\n```\nNow in your root project folder, you can call:\n```\n$ ptr run-task scripts\nFinished running task 'scripts' in 0.2 seconds\n```\n\n## What's with the weird (fluent) api?\nYou'll notice that instead of passing in constructor function parameters, you pass them in via property functions that act both as getters and setters.  You set the property by passing a parameter, and you get the property by calling it with no parameters.  Thus, using the task 'scripts' from above:\n```\nscripts.id(); // returns 'scripts'\nscripts.id('scripts2'); // sets id to 'scripts2' and returns itself, creating a fluent api\n\nscripts\n  .id('scripts')\n  .task(function() { ... });\n```\nIt's pretty intuitive and removes ambiguity between what function parameters are, what order they need to be passed, and how optional parameter logic is handled.  For more details, please see the API wiki section.\n",
  "readmeFilename": "README.md",
  "gitHead": "29e3acf0528b384b8abbb2a172913479c74654f1",
  "_id": "promise-task-runner@0.0.1",
  "_shasum": "4acc9b0b49ee1e32a3cfcb682e07f21b5c9025dd",
  "_from": "../promise-task-runner"
}
